import { existsSync, readFileSync } from "fs";
import { resolve } from "path";
import { warning } from "@daldalso/logger";
import { Project, SyntaxKind } from "ts-morph";
import dotenv from "dotenv";
import { dynamicSegmentPatterns } from "./constants.js";

const appRouterKeywords = [ "GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS" ];
// NOTE https://github.com/dsherret/ts-morph/issues/644
const typeTextPattern = /\b(NextTypedPage|NextTypedLayout|NextTypedRoute)\b/;

let project:Project;

/**
 * Initializes the project
 * @param rootPath Root path of the project
 * @throws Throws an error if tsconfig.json cannot be found
 */
export function initialize(rootPath:string):void{
  const tsConfigFilePath = resolve(rootPath, "tsconfig.json");
  if(!existsSync(tsConfigFilePath)){
    throw Error(`Could not find tsconfig.json: ${rootPath}`);
  }
  project = new Project({ useInMemoryFileSystem: true, skipLoadingLibFiles: true });
}

/**
 * Generates type definitions for pages
 * @param key Route key
 * @param path File path
 * @returns Generated type definition string
 */
export function generatePageDefinition(key:string, path:string):string{
  const R = [
    "// Auto-generated by @daldalso/next-typed-route",
    "import type { StaticPathFormOf } from \"@daldalso/next-typed-route\";"
  ];
  const parametersType = getParametersType(key);
  const file = project.createSourceFile(path, readFileSync(path).toString());
  let accepted = false;

  for(const v of file.getImportDeclarations()){
    R.push(v.getText());
  }
  for(const v of file.getTypeAliases()){
    R.push(v.getText());
  }
  for(const v of file.getInterfaces()){
    R.push(v.getText());
  }
  R.push(
    "declare module \"@daldalso/next-typed-route\"{",
    "  export interface NextPageTable{"
  );
  for(const v of file.getDefaultExportSymbol()?.getDeclarations() || []){
    if(v.isKind(SyntaxKind.ExportAssignment)){
      const type = v.getExpression().getType();
      if(!typeTextPattern.test(type.getText())){
        warning(`Unexpected default export type: ${type.getText()}`)['Path'](path);
        continue;
      }
      const [ , q ] = type.getAliasTypeArguments();

      R.push(
        `    '/${key}':{`,
        `      'params': ${parametersType},`,
        `      'query': ${q?.getText() || "never"}`,
        "    };"
      );
      accepted = true;
      break;
    }
    warning("Unexpected default export format")['Path'](path);
    continue;
  }
  project.removeSourceFile(file);
  if(!accepted) R.push(
    `    '/${key}':{ 'params': ${parametersType}, 'query': never };`
  );
  R.push("  }", "}");
  return R.join('\n');
}

/**
 * Generates type definitions for API endpoints
 * @param key Route key
 * @param path File path
 * @returns Generated type definition string, or undefined if:
 * - No valid HTTP method exports are found
 * - The exports are not valid variable declarations
 */
export function generateEndpointDefinition(key:string, path:string):string|undefined{
  const R = [
    "// Auto-generated by @daldalso/next-typed-route",
    "import type { Endpoint, emptyParamSymbol } from \"@daldalso/next-typed-route\";"
  ];
  const parametersType = getParametersType(key);
  const file = project.createSourceFile(path, readFileSync(path).toString());
  let accepted = false;

  for(const v of file.getImportDeclarations()){
    R.push(v.getText());
  }
  for(const v of file.getTypeAliases()){
    R.push(v.getText());
  }
  for(const v of file.getInterfaces()){
    R.push(v.getText());
  }
  R.push(
    "declare module \"@daldalso/next-typed-route\"{",
    "  export interface NextEndpointTable{"
  );
  for(const [ k, v ] of file.getExportedDeclarations()){
    if(!appRouterKeywords.includes(k)) continue;
    for(const w of v){
      if(!w.isKind(SyntaxKind.VariableDeclaration)) continue;
      const typeNode = w.getTypeNode();
      if(!typeNode?.isKind(SyntaxKind.TypeReference)){
        warning(`Unexpected type "${typeNode?.getText()}" for the variable "${k}"`)['Path'](path);
        continue;
      }
      const typeText = typeNode.getType().getText();
      if(!typeTextPattern.test(typeText)){
        warning(`Unexpected type "${typeText}" for the variable "${k}"`)['Path'](path);
        continue;
      }
      const [ requestType, responseType ] = typeNode.getTypeArguments();
      const requestSuffix = parametersType === "unknown" ? "" : `&{ params: ${parametersType} }`;

      R.push(`    '${k} /${key}':Endpoint<${requestType ? requestType.getText() : "unknown"}${requestSuffix}, ${responseType ? responseType.getText() : "void"}>;`);
      accepted = true;
    }
  }
  project.removeSourceFile(file);
  if(accepted){
    R.push("  }", "}");
    return R.join('\n');
  }
  return undefined;
}

/**
 * Generates type definitions for environment variables
 * @param key Environment variable key
 * @param path Path to .env file
 * @returns Generated type definition string
 */
// eslint-disable-next-line unicorn/prevent-abbreviations
export function generateEnvDefinition(key:string, path:string):string{
  const R = [
    "// Auto-generated by @daldalso/next-typed-route"
  ];
  const environment = dotenv.parse(readFileSync(path).toString());

  R.push(
    "declare namespace NodeJS{",
    "  export interface ProcessEnv{"
  );
  for(const k of Object.keys(environment)){
    R.push(`    ${k}: string;`);
  }
  R.push(
    "  }",
    "}"
  );
  return R.join('\n');
}

/**
 * Generates types for dynamic route parameters
 * @param key Route key
 * @returns Parameter type string
 */
export function getParametersType(key:string):string{
  const R:Record<string, string> = {};

  `/${key}`.replace(dynamicSegmentPatterns.optionalCatchAll, (_, g1:string) => {
    R[g1] = "?:string[]";
    return "/*";
  }).replace(dynamicSegmentPatterns.catchAll, (_, g1:string) => {
    R[g1] = ":string[]";
    return "/*";
  }).replace(dynamicSegmentPatterns.normal, (_, g1:string) => {
    R[g1] = ":string|typeof emptyParamSymbol";
    return "/*";
  });
  if(Object.keys(R).length){
    return "{" + Object.entries(R).map(([ k, v ]) => `'${k}'${v}`).join(',') + "}";
  }
  return "unknown";
}